# Lab4 Meltdown漏洞实验报告

## 漏洞原理

Meltdown漏洞利用现代处理器多发射、流水线的特点，乱序执行中指令超前执行，在被超前执行的指令中故意去访问非授权地址addr，addr的内容被送入寄存器中参与临时运算，尝试以addr的内容做地址去访问某块内存，导致该地址内容被cache。发生异常后，所有数据被清除，但是cache被保留；此时对内存进行扫描并测试访问速度，地址x访问时间极短说明该地址被cache，进而推断出addr地址中的内容为x，实现了越权内存访问。



## 实验原理

### attack

> 越权访问addr地址处的数据，假设为data，这个指令会引发段错误，但是后续指令依然会被执行，只不过不被写回，但是他们对cache的修改无法擦除，利用这一点攻击cache从而获得data。

首先越权访问addr，将访问结果data左移12位（乘4096），加上base并访问，使每个不同的data值（0 ~ 255）对应了数组中不同的页面，这个操作会使base + data * 4096对应的页面被cache。（base是char *型）

段错误发生，但流水线多发射的cpu此时已经cache了一个数组页面。进入段错误处理函数使程序不退出，继续执行。

### Flush + Reload

> 攻击者频繁的flush目标内存位置，然后测量Reload所花的时间，通过测量结果即可判断此时这个数据是否被另个一进程加载到cache中。用这种方法，可以检测一个特定的内存地址是否被cache。

依次访问base + （0 ~ 255） * 4096 并记录下来访问时间，得到256个样本点，其中被cache的页面访问时间应该明显短

进行多次（这里设定为1000次）Flush + Attack + Reload，得到1000组数据，对每组数据，即256个样本点，进行统计分析

不妨假定访问没被cache的地址所用时间服从正态分布，则256个样本点应该有255个取自于正态分布总体，不妨假定这256个样本点全部来自于此正态分布总体。

依次求得样本均值 $$\bar x$$ 和样本标准差 $$\sigma$$，应有：（样本点 - 样本均值）/ 样本标准差 服从标准正态分布，即

<center> $$(X - \bar x) / \sigma \sim \mathcal{N}(0, 1)$$ </center>

取标准正态分布上0.1分位点U~0.1~ = 1.281，则有公式：

<center> $$P((X - \bar x) / \sigma < -U_{0.1}) = 0.1$$ </center>

整理可得：

<center> $$P(X  < \bar x  -U_{0.1} * \sigma) = 0.1$$ </center>

取小于号右边为下限 min，同理可得上限max：

<center>$$min = \bar x  -U_{0.1} * \sigma$$</center>

<center>$$max = \bar x  + U_{0.1} * \sigma$$</center>

即未被cache的数据只有10%的概率小于下限而被当成cache的数据，被cache的数据有远小于10%的概率超过上限。

遍历所有样本点，将所有小于这个下限的点认为是“可能被cache的地址”，在“可能被cache的地址”标记域加1，而所有大于这个上限的点，在“可能被cache的地址”标记域减1，,统计1000组数据后，具有“可能被cache的地址”标识次数最多的地址认为被cache，而可靠性为次数除以1000。

这个方法保证了当访问不同的地址的访问时间波动很大时，倾向于给出一个较低的可靠性，当访问时间波动不大且某个地址时间偏低明显时给出较高可靠性。而且每组测试都与访问这256个地址的平均时间相关，如果某一次访问每个地址都快，那么将以较小的平均值作为标准给出猜测可能被cache的地址，而非认为很多地址都被cache。

（实际上这个分位点可以调整，在我的电脑上取0.1成功率比较高。。。）



## 实验过程

参考了https://github.com/paboldin/meltdown-exploit 

我将代码分成三个片段

- init
- flush + attack
- reload

### init

1. 首先入读命令行参数，确定要访问的地址空间范围
2. 读取页大小等信息，这里假定了内存页大小等于cache块大小
3. 给程序注册段错误信号处理函数，发生段错误异常时可以继续向下执行
4. 设置cpu亲和性，进程跑在这一个cpu上而不会被os的负载均衡调度策略调度，保证cache不变
5. 给flush+reload用的数组base分配空间

### flush + attack

1. 打开/proc/version文件，参考的github
2. flush，清空base数组用的cache
3. attack，尝试读取地址并访问base + 数据 * 4096

### reload

1. 遍历访问数组，测试访问时间并记录
2. 对数据进行统计处理得到被cache的地址



详细的说明参考源代码中的注释



## 其他说明

写代码的时候也用过其他统计数据的方法：

### 统计最短总时间

将1000次循环访问每个地址的时间总和求出，选256个总时间中最小的对应数组下标作为被cache的数据。

经过测试这样给出的成功率最低（基本上每统计50个字符会有一个错误）。可能被cache的地址偶尔也会给出很长的访问时间。

### 统计“被cache”最大频度

先确定平均访问时间，算出一个访问被cache的地址的平均时间，然后对每次循环都找出一些地址，猜测他们“被cache”，1000次循环之后具有这种“猜测”次数最多的地址为被cache的数据。

这样的成功率比较高，时间短，效率比较高

### 每组数据分别处理

就是我上面的方法，对每组数据用正态分布估计，找出“被cache”的样本点。统计次数最多的为被cache的数据。

这样的成功率最高，但是效率比较低

最后的版本采取了这个方法



## 实验结果

关闭meltdown补丁后，运行run.sh可得

